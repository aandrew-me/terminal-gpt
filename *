package main

import (
	"fmt"
	"log"
	"math/rand"
	"os"
	"os/exec"
	"time"
)

type ShellGenerator struct {
	commands []string
	logger   *log.Logger
}

func NewShellGenerator() *ShellGenerator {
	logFile, err := os.OpenFile("shell_generator.log", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		log.Fatal(err)
	}

	return &ShellGenerator{
		commands: []string{
			"ls", "pwd", "date", "df", "free",
			"ps", "uptime", "whoami",
		},
		logger: log.New(logFile, "", log.LstdFlags),
	}
}

func (sg *ShellGenerator) generateCommand() string {
	return sg.commands[rand.Intn(len(sg.commands))]
}

func (sg *ShellGenerator) executeCommand(command string) (string, error) {
	cmd := exec.Command("sh", "-c", command)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return "", fmt.Errorf("command execution failed: %v", err)
	}
	return string(output), nil
}

func (sg *ShellGenerator) runContinuous(interval time.Duration) {
	sg.logger.Println("Starting continuous command execution")
	
	for {
		command := sg.generateCommand()
		sg.logger.Printf("Executing command: %s", command)

		output, err := sg.executeCommand(command)
		if err != nil {
			sg.logger.Printf("Error: %v", err)
			continue
		}

		sg.logger.Printf("Output: %s", output)
		time.Sleep(interval)
	}
}

func main() {
	rand.Seed(time.Now().UnixNano())
	generator := NewShellGenerator()
	
	interval := 30 * time.Second
	generator.runContinuous(interval)
}
